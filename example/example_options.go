// Code generated by protoc-gen-go-options. DO NOT EDIT.
// source: example.proto
// debug: log enabled
package example

import (
	identifier "github.com/terwey/protoc-gen-go-options/example/identifier"
)

import (
	"google.golang.org/protobuf/proto"
)

// debug: generating options for message: BasicMessage
// BasicMessageOption defines a functional option for BasicMessage.
type BasicMessageOption func(*BasicMessage)

// NewBasicMessage creates a new BasicMessage.
// debug: qualifying identifier for name: BasicMessage
func NewBasicMessage(opts ...BasicMessageOption) *BasicMessage {
	m := &BasicMessage{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplyBasicMessageOptions applies the provided options to an existing BasicMessage.
// debug: qualifying identifier for name: BasicMessage
func ApplyBasicMessageOptions(m *BasicMessage, opts ...BasicMessageOption) *BasicMessage {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: BasicMessage
// debug: generating scalar field option for message: BasicMessage
// debug: determining field type for field: Name
// debug: field kind: string
// WithName sets the Name field.
// debug: field is not a list
// debug: qualifying identifier for name: BasicMessage
func WithName(value string) BasicMessageOption {
	return func(m *BasicMessage) {
		// debug: field is a scalar
		m.Name = proto.String(value)
	}
}

// debug: generating scalar field option for message: BasicMessage
// debug: determining field type for field: Age
// debug: field kind: int32
// WithAge sets the Age field.
// debug: field is not a list
// debug: qualifying identifier for name: BasicMessage
func WithAge(value int32) BasicMessageOption {
	return func(m *BasicMessage) {
		// debug: field is a scalar
		m.Age = proto.Int32(value)
	}
}

// debug: generating scalar field option for message: BasicMessage
// debug: determining field type for field: IsActive
// debug: field kind: bool
// WithIsActive sets the IsActive field.
// debug: field is not a list
// debug: qualifying identifier for name: BasicMessage
func WithIsActive(value bool) BasicMessageOption {
	return func(m *BasicMessage) {
		// debug: field is a scalar
		m.IsActive = proto.Bool(value)
	}
}

// debug: generating oneof options for message: BasicMessage
// debug: generating options for message: RepeatedFieldsMessage
// RepeatedFieldsMessageOption defines a functional option for RepeatedFieldsMessage.
type RepeatedFieldsMessageOption func(*RepeatedFieldsMessage)

// NewRepeatedFieldsMessage creates a new RepeatedFieldsMessage.
// debug: qualifying identifier for name: RepeatedFieldsMessage
func NewRepeatedFieldsMessage(opts ...RepeatedFieldsMessageOption) *RepeatedFieldsMessage {
	m := &RepeatedFieldsMessage{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplyRepeatedFieldsMessageOptions applies the provided options to an existing RepeatedFieldsMessage.
// debug: qualifying identifier for name: RepeatedFieldsMessage
func ApplyRepeatedFieldsMessageOptions(m *RepeatedFieldsMessage, opts ...RepeatedFieldsMessageOption) *RepeatedFieldsMessage {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: RepeatedFieldsMessage
// debug: generating repeated field option for message: RepeatedFieldsMessage
// debug: determining field type for field: Tags
// debug: field kind: string
// WithTags sets the Tags field.
// debug: qualifying identifier for name: RepeatedFieldsMessage
func WithTags(values ...string) RepeatedFieldsMessageOption {
	return func(m *RepeatedFieldsMessage) {
		m.Tags = values
	}
}

// debug: generating repeated field option for message: RepeatedFieldsMessage
// debug: determining field type for field: Values
// debug: field kind: int32
// WithValues sets the Values field.
// debug: qualifying identifier for name: RepeatedFieldsMessage
func WithValues(values ...int32) RepeatedFieldsMessageOption {
	return func(m *RepeatedFieldsMessage) {
		m.Values = values
	}
}

// debug: generating oneof options for message: RepeatedFieldsMessage
// debug: generating options for message: NestedMessage
// NestedMessageOption defines a functional option for NestedMessage.
type NestedMessageOption func(*NestedMessage)

// NewNestedMessage creates a new NestedMessage.
// debug: qualifying identifier for name: NestedMessage
func NewNestedMessage(opts ...NestedMessageOption) *NestedMessage {
	m := &NestedMessage{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplyNestedMessageOptions applies the provided options to an existing NestedMessage.
// debug: qualifying identifier for name: NestedMessage
func ApplyNestedMessageOptions(m *NestedMessage, opts ...NestedMessageOption) *NestedMessage {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: NestedMessage
// debug: generating nested field option for message: NestedMessage, optionless: false
// WithNewBasicForNestedMessage sets the Basic field with a new instance.
// debug: qualifying identifier for name: BasicMessage
// debug: qualifying identifier for name: NestedMessage
func WithNewBasicForNestedMessage(opts ...BasicMessageOption) NestedMessageOption {
	return func(m *NestedMessage) {
		// debug: qualifying identifier for name: BasicMessage
		m.Basic = NewBasicMessage(opts...)
	}
}

// debug: generating direct nested field option for message: NestedMessage
// WithBasic sets the Basic field directly.
// debug: qualifying identifier for name: NestedMessage
func WithBasic(value *BasicMessage) NestedMessageOption {
	return func(m *NestedMessage) {
		m.Basic = value
	}
}

// debug: generating scalar field option for message: NestedMessage
// debug: determining field type for field: Description
// debug: field kind: string
// WithDescription sets the Description field.
// debug: field is not a list
// debug: qualifying identifier for name: NestedMessage
func WithDescription(value string) NestedMessageOption {
	return func(m *NestedMessage) {
		// debug: field is a scalar
		m.Description = proto.String(value)
	}
}

// debug: generating oneof options for message: NestedMessage
// debug: generating options for message: OneofMessage
// OneofMessageOption defines a functional option for OneofMessage.
type OneofMessageOption func(*OneofMessage)

// NewOneofMessage creates a new OneofMessage.
// debug: qualifying identifier for name: OneofMessage
func NewOneofMessage(opts ...OneofMessageOption) *OneofMessage {
	m := &OneofMessage{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplyOneofMessageOptions applies the provided options to an existing OneofMessage.
// debug: qualifying identifier for name: OneofMessage
func ApplyOneofMessageOptions(m *OneofMessage, opts ...OneofMessageOption) *OneofMessage {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: OneofMessage
// debug: generating oneof options for message: OneofMessage
// WithText sets the Choice oneof field to Text.
// debug: oneof field is not a list
// debug: determining field type for field: Text
// debug: field kind: string
// debug: qualifying identifier for name: OneofMessage
func WithText(value string) OneofMessageOption {
	return func(m *OneofMessage) {
		// debug: oneof field is not a list
		m.Choice = &OneofMessage_Text{
			Text: value,
		}
	}
}

// WithNumber sets the Choice oneof field to Number.
// debug: oneof field is not a list
// debug: determining field type for field: Number
// debug: field kind: int32
// debug: qualifying identifier for name: OneofMessage
func WithNumber(value int32) OneofMessageOption {
	return func(m *OneofMessage) {
		// debug: oneof field is not a list
		m.Choice = &OneofMessage_Number{
			Number: value,
		}
	}
}

// debug: generating options for message: ComplexMessage
// ComplexMessageOption defines a functional option for ComplexMessage.
type ComplexMessageOption func(*ComplexMessage)

// NewComplexMessage creates a new ComplexMessage.
// debug: qualifying identifier for name: ComplexMessage
func NewComplexMessage(opts ...ComplexMessageOption) *ComplexMessage {
	m := &ComplexMessage{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplyComplexMessageOptions applies the provided options to an existing ComplexMessage.
// debug: qualifying identifier for name: ComplexMessage
func ApplyComplexMessageOptions(m *ComplexMessage, opts ...ComplexMessageOption) *ComplexMessage {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: ComplexMessage
// debug: generating nested field option for message: ComplexMessage, optionless: false
// WithNewNestedForComplexMessage sets the Nested field with a new instance.
// debug: qualifying identifier for name: NestedMessage
// debug: qualifying identifier for name: ComplexMessage
func WithNewNestedForComplexMessage(opts ...NestedMessageOption) ComplexMessageOption {
	return func(m *ComplexMessage) {
		// debug: qualifying identifier for name: NestedMessage
		m.Nested = NewNestedMessage(opts...)
	}
}

// debug: generating direct nested field option for message: ComplexMessage
// WithNested sets the Nested field directly.
// debug: qualifying identifier for name: ComplexMessage
func WithNested(value *NestedMessage) ComplexMessageOption {
	return func(m *ComplexMessage) {
		m.Nested = value
	}
}

// debug: generating repeated field option for message: ComplexMessage
// debug: determining field type for field: NestedList
// debug: field kind: message
// WithNestedList sets the NestedList field.
// debug: qualifying identifier for name: ComplexMessage
func WithNestedList(values ...*NestedMessage) ComplexMessageOption {
	return func(m *ComplexMessage) {
		m.NestedList = values
	}
}

// debug: generating map field option for message: ComplexMessage
// debug: determining field type for field: Key
// debug: field kind: string
// debug: determining field type for field: Value
// debug: field kind: int32
// WithMetadata sets the Metadata field.
// debug: qualifying identifier for name: ComplexMessage
func WithMetadata(value map[string]int32) ComplexMessageOption {
	return func(m *ComplexMessage) {
		m.Metadata = value
	}
}

// debug: generating oneof options for message: ComplexMessage
// debug: generating options for message: Foo
// FooOption defines a functional option for Foo.
type FooOption func(*Foo)

// NewFoo creates a new Foo.
// debug: qualifying identifier for name: Foo
func NewFoo(opts ...FooOption) *Foo {
	m := &Foo{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplyFooOptions applies the provided options to an existing Foo.
// debug: qualifying identifier for name: Foo
func ApplyFooOptions(m *Foo, opts ...FooOption) *Foo {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: Foo
// debug: generating nested field option for message: Foo, optionless: true
// WithNewIdForFoo sets the Id field with a new instance.
// debug: qualifying identifier for name: Foo
func WithNewIdForFoo() FooOption {
	return func(m *Foo) {
		// debug: qualifying identifier for name: Identifier
		m.Id = identifier.NewIdentifier()
	}
}

// debug: generating direct nested field option for message: Foo
// WithIdForFoo sets the Id field directly.
// debug: qualifying identifier for name: Foo
func WithIdForFoo(value *identifier.Identifier) FooOption {
	return func(m *Foo) {
		m.Id = value
	}
}

// debug: generating oneof options for message: Foo
// debug: generating options for message: Bar
// BarOption defines a functional option for Bar.
type BarOption func(*Bar)

// NewBar creates a new Bar.
// debug: qualifying identifier for name: Bar
func NewBar(opts ...BarOption) *Bar {
	m := &Bar{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplyBarOptions applies the provided options to an existing Bar.
// debug: qualifying identifier for name: Bar
func ApplyBarOptions(m *Bar, opts ...BarOption) *Bar {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: Bar
// debug: generating nested field option for message: Bar, optionless: true
// WithNewIdForBar sets the Id field with a new instance.
// debug: qualifying identifier for name: Bar
func WithNewIdForBar() BarOption {
	return func(m *Bar) {
		// debug: qualifying identifier for name: Identifier
		m.Id = identifier.NewIdentifier()
	}
}

// debug: generating direct nested field option for message: Bar
// WithIdForBar sets the Id field directly.
// debug: qualifying identifier for name: Bar
func WithIdForBar(value *identifier.Identifier) BarOption {
	return func(m *Bar) {
		m.Id = value
	}
}

// debug: generating oneof options for message: Bar
// debug: generating options for message: SomeMessage
// SomeMessageOption defines a functional option for SomeMessage.
type SomeMessageOption func(*SomeMessage)

// NewSomeMessage creates a new SomeMessage.
// debug: qualifying identifier for name: SomeMessage
func NewSomeMessage(opts ...SomeMessageOption) *SomeMessage {
	m := &SomeMessage{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplySomeMessageOptions applies the provided options to an existing SomeMessage.
// debug: qualifying identifier for name: SomeMessage
func ApplySomeMessageOptions(m *SomeMessage, opts ...SomeMessageOption) *SomeMessage {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: SomeMessage
// debug: generating nested field option for message: SomeMessage, optionless: true
// WithNewIdentifierForSomeMessage sets the Identifier field with a new instance.
// debug: qualifying identifier for name: SomeMessage
func WithNewIdentifierForSomeMessage() SomeMessageOption {
	return func(m *SomeMessage) {
		// debug: qualifying identifier for name: Identifier
		m.Identifier = identifier.NewIdentifier()
	}
}

// debug: generating direct nested field option for message: SomeMessage
// WithIdentifier sets the Identifier field directly.
// debug: qualifying identifier for name: SomeMessage
func WithIdentifier(value *identifier.Identifier) SomeMessageOption {
	return func(m *SomeMessage) {
		m.Identifier = value
	}
}

// debug: generating repeated field option for message: SomeMessage
// debug: determining field type for field: Include
// debug: field kind: message
// WithInclude sets the Include field.
// debug: qualifying identifier for name: SomeMessage
func WithInclude(values ...*identifier.Identifier) SomeMessageOption {
	return func(m *SomeMessage) {
		m.Include = values
	}
}

// debug: generating oneof options for message: SomeMessage
// debug: generating options for message: NoInit
// NoInitOption defines a functional option for NoInit.
type NoInitOption func(*NoInit)

// ApplyNoInitOptions applies the provided options to an existing NoInit.
// debug: qualifying identifier for name: NoInit
func ApplyNoInitOptions(m *NoInit, opts ...NoInitOption) *NoInit {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: NoInit
// debug: generating scalar field option for message: NoInit
// debug: determining field type for field: NoInitName
// debug: field kind: string
// WithNoInitName sets the NoInitName field.
// debug: field is not a list
// debug: qualifying identifier for name: NoInit
func WithNoInitName(value string) NoInitOption {
	return func(m *NoInit) {
		// debug: field is a scalar
		m.NoInitName = proto.String(value)
	}
}

// debug: generating oneof options for message: NoInit
// debug: skipping message because it has no fields: EmptyMessage
// debug: generating options for message: FooBarWithEnum
// FooBarWithEnumOption defines a functional option for FooBarWithEnum.
type FooBarWithEnumOption func(*FooBarWithEnum)

// NewFooBarWithEnum creates a new FooBarWithEnum.
// debug: qualifying identifier for name: FooBarWithEnum
func NewFooBarWithEnum(opts ...FooBarWithEnumOption) *FooBarWithEnum {
	m := &FooBarWithEnum{}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// ApplyFooBarWithEnumOptions applies the provided options to an existing FooBarWithEnum.
// debug: qualifying identifier for name: FooBarWithEnum
func ApplyFooBarWithEnumOptions(m *FooBarWithEnum, opts ...FooBarWithEnumOption) *FooBarWithEnum {
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// debug: generating field options for message: FooBarWithEnum
// debug: generating scalar field option for message: FooBarWithEnum
// debug: determining field type for field: Status
// debug: field kind: enum
// WithStatus sets the Status field.
// debug: field is an enum
// debug: qualifying identifier for name: FooBarWithEnum
func WithStatus(value *FooBarWithEnum_Status) FooBarWithEnumOption {
	return func(m *FooBarWithEnum) {
		// debug: field is an enum
		m.Status = value
	}
}

// debug: generating oneof options for message: FooBarWithEnum
